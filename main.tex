\input{main/init}
\selectlanguage{ngerman}
\begin{document}
    \newSection{Angular}
    \newSection{Maven}
    \newSection{Spring Boot}
        Spring ist Framework, dass sich um nötige Abhängigkeiten eines
        Projekts kümmert und diese mittels \quote{Dependency
        Injection}{Cosmina}{S.6} (DI) dynamisch einbindet.
        Dabei
        erstellt das Framework die für das Projekt benötigten Objekte
        und übergibt diese anschließend an das Projekt. Dieses Design
        Pattern nennt sich \quote{Inversion of Control}{Cosmina}{S.6}(IOC).
        \newSubSection{Inversion of Control und Dependency Injection}
        Grundlegend gibt es vier verschiedene Arten des IOCs, nämlich
        das Dependency Lookup (DL) und die Dependency Injection (DI)
        welche dann auch wieder auf verschiedene Weisen auftreten: 
        \begin{itemize}
            \item Dependency Pull
            \item Contextualized dependency lookup
            \item Consturctor dependency injection
            \item Setter dependecy injection
        \end{itemize} \source{Cosmina}{vgl. S.46}
        Generell setzt Spring dabei auf DI in manchen Bereichen lässt
        sich DL allerdings nicht vermeiden, wie wir beispielsweise an
        folgendem Beispiel-Programm sehen können. Hier wird das DL in
        der main Methode unumgänglich:
        \includeJava[firstline=11,lastline=20]{HelloWorld}{lib}
        Bei Java End to End Anwendungen wird häufig von einer äußeren
        Schnittstelle, meist dem Nutzer-Interface auf die darunter
        liegenden Schichten zugegriffen. Diese Schichten benötigen
        sich gegenseitig, da das Nutzer-Interface auf die Daten aus
        der Datenbank zugreifen muss. Hier kann also mit IOC
        gearbeitet werden und das für das Nutzer-Interface benötigte
        Object für den Datenzugriff erstellt
        werden.\source{Cosmina}{vgl. S.616}\\ 
        Das Herzstück des Spring Frameworks ist also der
        IOC-Container, der wiederum auf den beiden Packages
        \textbf{org.springframework.beans} label{Packages:Beans} und
        \textbf{org.springframework.context} basiert.
        das ref{Packages:Beans} Package bringt einige Annotationen
        mitsich:
        \begin{tbl}{|B{c}{t}X[1]|}
            \hline
            @Bean & {Methoden, die mit @Bean ausgestattet sind
            erzeugen ein Object, dass vom IOC Container erkannt und
            verwaltet wird.}\\
            @Component & {Dadurch werden Klassen als Bean
            gekennzeichnet.}\\
            @PostConstruct & {Mit @PostConstruct markierte Methoden
            werden nach der Injezierung durch den IOC Container
            ausgeführt. So können zum Beispiel Testklassen mit Werten
            ausgestattet werden.}\\
            @Controller & {Markiert eine Klasse als Bean die durch
            Spring MVC, ein Modul, verwaltet wird und auf Web-Anfragen
            reagiert.}\\
            @Repository & {Markiert eine Klasse als Bean, die einen
            Datenzugang ermöglicht.}\\ 
            @Autowired & {Für Constructoren benötigte Parameter
            werden durch diese Markierung durch den IOC Container
            erstellt. Bei nur einem Construktor ist diese Markierung
            nicht notwendig.}\\
            \hline
        \end{tbl}
        %https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
        % Für weitere Anntoations: https://github.com/gindex/spring-boot-annotation-list
        \newSubSection{Module und Annotations}
        Spring bringt eine große Anzahl an Modulen mit eine
        ausführliche Auflistung der Module findet sich auf S.22 von
        \source{Cosmina}. Für die Funktionsweise der Module sind
        sogenannte Annotations ausschlaggebend. Sie definieren welcher
        Code von Spring behandelt wird und wie er behandelt wird.

        Aplications.properties
        Hier können verschiedene Einstellungen für die gesamte
        Anwendung definiert werden. Zum Beispiel der root Pfad
        
        Hier nun eine Auflistung der für dieses Projekt wichtigen
        Module und deren Annotations:
        \paragraph{Spring-Boot-Starter-Web}
        Web ist, das wohl grundlegenste Modul dieses Projekts. Es
        ermöglicht dem Nutzer über den Browser Anfragen an das
        Programm zu stellen. Hierzu nutzt Spring einige Annotations:
        \begin{tbl}{|B{c}{t}X|}
        %\begin{xltabular}[c]{\textwidth}{|\blabel{c}X|}
            \hline
            @ResponseBody & Markierte Methode liefert Daten an den
            Absender einer Anfrage zurück.\\
            @ResponseStatus & Markierte Methoden liefern, wenn auch
            nicht zwangsweise Daten, mindestens aber den Status der
            Anfrage an den Absender zurück. Diese Annotation kann auch
            bei Exceptions angebracht werden.\\
            @RequestBody & Ermöglicht den Zugriff auf die in der
            Anfrage enthaltenen Variablen zuzugreifen. Meistens sind
            diese Daten in Form eines Json formats angegeben.\\ 
            @PathVariable & Markierte Variable liegt im Pfad der
            Anfrage und kann durch die Markierung dynamisch verwendet
            werden.\\ 
            @GetMapping & Markierte Methode reagiert auf GET
            Anfragen\\ 
            @PostMapping & Markierte Methode reagiert auf POST
            Anfragen\\ 
            @PutMapping & Markierte Methode reagiert auf PUT
            anfragen\\
            @DeleteMapping & Markierte Methode reagiert auf DELETE
            Anfragen\\
            \hline
        %\end{xltabular}
        \end{tbl}
        Oben gennante Mappings können auch auf eine Klasse angewandt
        werden. Die Mappings innerhalb einer solchen Klasse müssen
        entsprechend angepasst werden. Für Methoden die einen ResponseBody
        liefern ist es sinnvoll diesen als Optional<> anzugeben.

        ResponseStatus(HttpStatus.CREATED) teilt bei POST-Methoden dem
        Sender mit, ob ein Objekt erstellt wurde oder nicht.
        HttpStatus.NO CONTENT wird dann verwendet, wenn tatsächlich
        keine Daten zurück geliefert werden sollen.

        \paragraph{spring-boot-starter-validation}
        Mit hilfe dieses Moduls ist es möglich die vom Nutzer
        eingegebenen Daten einfach zu überprüfen. Hierrü nutzt das
        Modul Anotations:
        \begin{tbl}{|B{c}{t}X|}
            \hline
            @Valid & Ein mit @Valid markierter Parameter wird erst
            validiert werden bevor er verwendet wird.\\ 
            @NotEmpty & Markierte Variable darf nicht leer oder
            null sein.\\
            @NotNull & Markierte Variable darf nicht null sein.\\
            @Past & Angegbenes Datum oder Zeit muss in der
            Vergangenheit liegen.\\
            @Future & Angegebenes Datum oder Zeit muss in der
            Zukunft liegen.\\
            \hline
        \end{tbl}
        Es ist auch möglich weiterer solcher Annotationen selbst zu
        schreiben.
        \paragraph{spring-boot-starter-jdbc}
        \paragraph{spring-boot-starter-data-jdbc}
        Bringt einige neue Interfaces und Annotations die den Zugriff
        auf die Datenbank erleichtern.
        \begin{tbl}{|B{c}{t}X|}
            \hline
            @Id & Markierte Variable wird als die Id der Tabelle
            angesehen.\\
            @Version & Markierte Variable gibt an wie häufig eine
            Zeile schon bearbeitet wurde\\
            @NoRepositoryBean & ??\\
            \hline
        \end{tbl}
        Interfaces: CrudRepository und ListCrudRepository benötigen
        beide einmal den Datentyp den sie managen wollen und den
        Datentyp der id.
        Das ListCrudRepository baut auf dem CrudRepository auf und
        bringt einige Methoden mit:
        \begin{tbl}{|cB{c}{t}X|}
            \hline
            ReturnTyp & Methodenname & Beschreibung\\
            List<S> & saveAll & Speichert zum Beispiel eine Liste
            von Daten des Datentyps S, die zumindest vom Ursprungsdatentyp T erben.\\
            List<T> & findAll & Liefert eine Liste aller Daten des
            Datentyps T die sich in der Datenbank bzw. dem Repository
            befinden.\\
            List<T> & findAllById & Liefert eine Liste aller
            Daten des Datentyps T deren Id mit einer der übergebenen
            Ids übereinstimmte. Als Übergabeparameter wird hier etwas
            itterrierbares wie z.B. eine Liste erwartet.\\
            \hline
        \end{tbl}
        Das Crud Repository bringt dann noch weitere Methoden mit:
        \begin{tbl}{|cB{c}{t}X|}
            \hline
            ReturnTyp & Methodenname & Beschreibung\\
            S & save & ??\\
            Iterable<S> & saveAll & ??\\
            Optional<T> & findById & ??\\
            boolean & existsById & ??\\
            Iterable<T> & findAllById & ??\\
            Iterable<T> & findAll & ??\\
            long & count & ??\\
            void & deleteById & ??\\
            void & delete & ??\\
            void & deleteAllById & ??\\
            void & deleteAll & ??\\
            \hline
        \end{tbl}
        All diese Methoden funktionieren direkt ohne Implementierung.
        Warum? Da das erstellte Interface des Repositorys vom
        CrudRepository erbt, erbt es auch die Annotierung. Damit hat
        Spring die möglichkeit es während des Start der Application zu
        implementieren indem es Repository Factory beans anlegt, die
        dann wenn nötig das erstellte Repository injezieren können.
        \newSubSection{Databases}
        Hier werden einige neue Module verwendet. 
        PostgresSQL -> Eben eine SQL Datenbank
        Docker - Compose -> Erstellt einen passenden Container (-- Ich
        denke wie so eine Python umgebung in der eben passende
        Variablen definiert werden) für die
        Datenbank. Z.b. wird hier der Nutzer und das Passwort
        festgelegt.
    \newSection{Bibliobytes}
        \newSubSection{Einleitung}
        \newSubSection{Zielsetzung}
            \subsubsection{Anforderungen in Form von User-Storys}
            \begin{tbl}[User-Storys]{|c|X|c|c|}
                \hline
                \textbf{Kategorie} & \textbf{Beschreibung} &
                \textbf{Ge\-wicht} & \textbf{Referenz}\\ 
                \hline
                Epic & Als Kunde möchte ich Mock-Ups vom Projektverlauf haben. &
                12 & E1 \phantomsection\\ 
                \hline
                User-Story & Als Kunde möchte ich ein Mock-Up von der Landing
                Page haben. & 2 & E1U1\\
                User-Story & Als Kunde möchte ich ein Mock-Up vom Dashboard
                haben. & 2 & E1U2\\ 
                User-Story & Als Kunde möchte ich ein Mock-Up vom Katalog haben.
                & 2 & E1U3\\
                User-Story & Als Kunde möchte ich ein Mock-Up von der
                Kategorisierung haben. & 2 & E1U4\\ 
                User-Story & Als Kunde möchte ich ein Mock-Up von der
                Suchfunktion haben. & 2 & E1U5\\ 
                User-Story & Als Kunde möchte ich ein Mock-Up von der
                Ausleihhistorie haben. & 2 & E1U6\\
                \hline 
                Epic & Als Nutzer möchte ich das System mit meinem eigenen
                Benutzerkonto nutzen können. & 50 & E2\\ 
                \hline
                User-Story & Als Nutzer möchte ich auf einer Landing Page
                landen. & 3 & E2U1\\ 
                User-Story & Als Nutzer möchte ich mich registrieren können. & 5
                & E2U2\\
                User-Story & Als Nutzer möchte ich eine verifizierungsemail nach
                dem erstellen des Accounts erhalten. & 3 & E2U3\\
                User-Story & Als Nutzer möchte ich mich einloggen können. & 3 &
                E2U4\\
                User-Story & Als Nutzer möchte ich die Objekte durchsuchen
                können. & 4 & E2U5\\
                User-Story & Als Nutzer möchte ich anhand der Farbe den
                Überfälligkeitsstatus von verliehenen Objekten erkennen können.
                & 4 & E2U6\\ 
                User-Story & Als Nutzer möchte ich Informationen über Objekte
                einsehen können & 4 & E2U7\\ 
                User-Story & Als Nutzer möchte ich Objekte für mich selbst
                ausleihen können. & 5 & E2U8\\
                User-Story & Als Nutzer möchte ich Objekte für externe Personen
                ausleihen können. & 5 & E2U9\\
                User-Story & Als Nutzer möchte ich meine eigene Ausleihhistorie
                einsehen können. & 4 & E2U10\\ 
                User-Story & Als Nutzer möchte ich eine Email erhalten, wenn ich
                die Ausleihfrist eines Buches überschreite & 7 & 
                E2U11\\ 
                User-Story & Als Nutzer möchte ich Objekte zurück geben können.
                & 3 & E2U12\\ 
                \hline 
                Epic & Als Admin möchte ich Benutzer verwalten können. & 22 & 
                E3\\ 
                \hline
                User-Story & Als Admin möchte ich Nutzer verifizieren können. &
                3 & E3U1\\
                User-Story & Als Admin möchte ich Informationen über Benutzer
                einsehen können. & 5 & E3U2\\
                User-Story & Als Admin möchte ich Nutzern ihre Verifizierung
                entziehen können. & 3 & E3U3\\
                User-Story & Als Admin möchte ich Nutzer zu Admins machen
                können. & 3 & E3U4\\
                User-Story & Als Admin möchte ich Nutzern ihren Adminstatus
                entziehen können. & 3 & E3U5\\
                User-Story & Als Admin möchte ich die Ausleihhistorie alle
                Nutzer einsehen können. & 5 & E3U6\\
                \hline
                Epic & Als Admin möchte ich Objekte verwalten können. & 19 & 
                E4\\ 
                \hline
                User-Story & Als Admin möchte ich Objekte aus einer
                Excel-Tabelle importieren können. & 3 & E4U1\\
                User-Story & Als Admin möchte ich Objekte hinzufügen können. & 3
                & E4U2\\
                User-Story & Als Admin möchte ich Objekte entfernen können. & 4
                & 
                E4U3\\
                User-Story & Als Admin möchte ich Informationen über Objekte
                verändern können. & 5 & E4U4\\
                User-Story & Als Admin möchte ich die Ausleihhistorie von
                Objekten einsehen können. & 4 & E4U5\\
                \hline
            \end{tbl}
        \newSubSection{Umsetzung}
            \subsubsection{Scrum}
            \subsubsection{Sprints und Dokumentation}
            \begin{itemize}
                \item Im ersten Sprint werden die User-Storys
                    \refctab{E1U1}{2}, 
                    \refctab{E1U2}{3}, 
                    \refctab{E1U3}{4}, 
                    \refctab{E1U4}{5}, 
                    \refctab{E1U5}{6}, 
                    \refctab{E2U1}{9}, 
                    \refctab{E2U2}{10}, 
                    \refctab{E2U3}{11}, 
                    \refctab{E2U4}{12}, 
                    \refctab{E3U1}{22}, 
                    \refctab{E3U2}{23}, 
                    und
                    \refctab{E3U3}{24}
                    inklusive Dokumentation abgeschlossen. Der
                    erste Sprint sollte ende August abgeschlossen sein.
                \item Im zweiten Sprint werden die User-Storys
                    \refctab{E3U4}{25},
                    \refctab{E3U5}{26},
                    \refctab{E4U1}{29},
                    \refctab{E2U5}{13},
                    \refctab{E4U2}{30},
                    \refctab{E4U3}{31},
                    \refctab{E2U7}{15},
                    \refctab{E4U4}{32}
                    und
                    \refctab{E2U8}{16}
                    inklusive
                    Dokumentation abgeschlossen sein. Der zweite Sprint endet
                    vorraussichtlich ende September.
                \item Im dritten un letzten Sprint werden die User-Storys
                    \refctab{E2U9}{17},
                    \refctab{E1U6}{7},
                    \refctab{E2U10}{18},
                    \refctab{E3U6}{27},
                    \refctab{E4U5}{33},
                    \refctab{E2U11}{19},
                    \refctab{E2U6}{14}
                    und
                    \refctab{E2U12}{20}
                    inklusive
                    Dokumentation abgeschlossen werden. Der dritte und letzte
                    Sprint endet anfang Dezember.
            \end{itemize}
        \newSubSection{Sprint 1}
        Berichte zu den einzelnen User-Storys:\newline
        \textbf{\refctab{E1U1}{3} - Landing Page}\\
            Da die erste Version des Bibliobytes-Projekts im
            Django-Framework geschrieben wurde, dieses Projekt jetzt
            aber auf Spring Boot und Angular basieren soll war diese
            User-Story aufgrund des für sie notwendigen lernzuwachses
            eine der bisher schwierigsten.\newline
        \textbf{\refctab{E1U2}{4}}\\ ... \newline
        \textbf{\refctab{E1U3}{5}}\\ ... \newline
        \textbf{\refctab{E1U4}{6}}\\ ... \newline
        \textbf{\refctab{E1U5}{7}}\\ ... \newline
        \textbf{\refctab{E2U1}{10}}\\ ... \newline
        \textbf{\refctab{E2U2}{11}}\\ ... \newline
        \textbf{\refctab{E2U3}{12}}\\ ... \newline
        \textbf{\refctab{E2U4}{13}}\\ ... \newline
        \textbf{\refctab{E3U1}{23}}\\ ... \newline
        \textbf{\refctab{E3U2}{24}}\\ ... \newline
        \textbf{\refctab{E3U3}{25}}\\ ... \newline
        \newSubSection{Sprint 2}
        \newSubSection{Sprint 3}
        \reftab{@Bean}{3.1:1}
        \reftab{@Component}{3.1:2}
        \reftab{@PostConstruct}{3.1:3}
        \reftab{@Controller}{3.1:4}
        \reftab{@Repository}{3.1:5}
        \reftab{@Autowired}{3.1:6}
        \reftab{@DeleteMapping}{3.2:1}
\end{document}
